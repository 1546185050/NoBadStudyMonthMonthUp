# 《重构改善既有代码的设计》4月读书笔记



## 章节三、代码的坏味道

### Duplicated Code（重复的代码）

如果在一个以上的地点看到相同的程序结构，那么当可肯定：设法将它们合而为一，程序会变得更好。

这时候我需要做的就是采用Extract Method提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。

### Long Method（过长函数）

程序愈长愈难理解。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。

### Large Class（过大类）

如果想利用单一class做太多事情，其内往往就会出现太多instance变量。一旦如此，Duplicated Code也就接踵而至了。

可以运用Extract Class将数个变量一起提炼至新class内。提炼时应该选择class内彼此相关的变量，将它们放在一起。

### Long Parameter List（过长参数列）

太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。可使用Introduce Parameter Object 为它们制造出一个「参数对象」。

### Feature Envy（依恋情结）

函数对某个class的兴趣高过对自己所处之host class的兴趣。例如，某个函数 为了计算某值，从另一个对象那儿调用几乎半打的取值函数。这时候应该使用 Extract Method 把这一部分提炼到独立函数中，再使用Move Method 带它去它的梦中家园。

### Data Clumps（数据泥团）

两个classes内的相同值域（field）、许多函数签名式中的相同参数。这些「总是绑在一起出现的数据」真应该放进属于它们自己的对象中。

### Switch Statements（switch惊悚现身）

 switch语句的问题在于重复。如果要为它添加一个新的子句，你必须找到所有switch语句 并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。

### Parallel Inheritance Hierarchies（平行继承体系）

增加子类时需要给其他类也增加子类。可以通过搬移函数、搬移字段消除这种重复性。

### Lazy Class（冗赘类）

存在价值不大的类或组件。如果某些subclass没有做满足够工作，可以折叠继承体系。对于几乎没用的组件，你应该以Inline Class对付它们。

### Temporary Field（令人迷惑的暂时值域）

在变量未被使用的情况下猜测当初其设置目的，会让你发疯。使用 Extract Class 给这个可怜的孤儿创造一个家，然后把所有和这个变 量相关的代码都放进这个新家。

### Message Chains（过度耦合的消息链）

一长串的函数调用或者临时变量。隐藏“委托关系”、提炼函数、搬移函数。

### Middle Man（中间转手人）

某个类有一半的函数委托给其他类，这时候我们应该移除中间人。如果中间人还有其他行为或者方法，我们以继承取代委托。

### Alternative Classes with Different Interfaces（异曲同工的类）

如果两个函数做同一件事，却有着不同的签名式，运用Rename Method 根据它们的用途重新命名。但这往往不够，请反复运用Move Method 将某些行为移入classes，直到两者的协议（protocols ）一致为止。

### Incomplete Library Class（不完美的程序库类）

需要给某个库增加函数，但无法修改这个类。可以引入外加函数、引用本地扩展解决这个问题。

### Data Class（纯稚的数据类）

所谓Data Class是指：它们拥有一些值域（fields），以及用于访问（读写〕这些值域的函数，除此之外一无长物。你应该在别人注意到它们之前，立刻运用Encapsulate Field 将它们封装起来。

### Comments（过多的注释）

当你感觉需要撰写注释，请先尝试重构，试着让所有注释都变得多余。注释已经变得多余了，因为代码已经清楚说明了一切。如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己「为什 么做某某事」。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。



## 章节四、构建测试体系

自我测试代码的价值：

程序员把最多的时间耗在调试，编写代码其实只占非常小的不发。修复错误通常是比较快的，但找出错误却是噩梦一场。当你修好一个错误，总是会有另一个错误出现，而且肯定要很久以后才会注意到它。因此构建一个可靠的自动化测试，能大大提高我们的工作效率。

这一章还大概的介绍了一下JUnit测试框架的使用，其实这一章并不是本书的重点，本书谈的是重构，而重构需要测试。我们大概掌握了JUnit测试框架的使用就可以了。



## 章节五、重构名录

这一章， 作者先介绍了重构的记录格式：名称-->概要-->动机-->做法-->范例

工作中用AS， 在开发过程中比较方便， 这一点可以得到控制，但是书中提到编译器可能存在的缺点， 总结如下:

1. 被删除的部分在继承体系中声明不止一次，那么编译器会被迷惑。

2. 编译器查找会拖慢速度， 这点没有明显感觉到， 或者时代不同， 工具不同。

3. 编译器无法找到通过反射机制而得到的引用点。 实际项目没遇到过。

作者推荐的是结合菜单选项或者文本查找方式。

